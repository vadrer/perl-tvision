{{{
# this file is for Text::Template with DELIMITERS=>['{{{','}}}'] option,
# So it could be processed this way:
# perl -MText::Template -we "Text::Template::fill_in_file('typemap.in', DELIMITERS=>['{{{','}}}'],OUTPUT => \*STDOUT)" > typemap
# alternatively, this file could be transformed with vim-plugin vispen
}}}
#define Uses_TBackground
#define Uses_TView
#define Uses_TButton
#define Uses_TRect
#define Uses_TStatusLine
#define Uses_TStaticText
#define Uses_TLabel
#define Uses_TStatusDef
#define Uses_TStatusItem
#define Uses_TCheckBoxes
#define Uses_TRadioButtons
#define Uses_TScroller
#define Uses_TScrollBar
#define Uses_TIndicator
#define Uses_TInputLine
#define Uses_TEditor
#define Uses_TKeys
#define Uses_MsgBox
#define Uses_fpstream
#define Uses_TEvent
#define Uses_TDeskTop
#define Uses_TApplication
#define Uses_TWindow
#define Uses_TEditWindow
#define Uses_TDialog
#define Uses_TScreen
#define Uses_TSItem
#define Uses_TMenu
#define Uses_TMenuItem
#define Uses_TMenuBar
#define Uses_TSubMenu

#include <tvision/tv.h>

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "TVision.h"

MODULE=TVision::TApplication PACKAGE=TVision::TApplication

TVApp* new()
    CODE:
        RETVAL = new TVApp();
        // RETVAL = get_sv("TVision::TApplication::the_app", GV_ADD);
	//do_sv_dump(0, PerlIO_stderr(), RETVAL, 0, 10, 0,0);
    OUTPUT:
	RETVAL

TDeskTop* deskTop(TVApp *tapp)
    CODE:
        RETVAL = tapp->deskTop;
    OUTPUT:
	RETVAL

void run(TVApp *tapp)
    CODE:
	tapp->run();

{{{
    # constructors:
    join '', map {
        my ($fun, $args) = /^\s*(\S+)\s*\(\s*(.*?)\s*\)/;
	$args =~ s/TStringView/char */g;
	my $trecta = $args=~s/^TRect// ? 'int _ax, int ay, int bx, int by' : '';
	my $trectv = $trecta ? 'TRect(_ax,ay,bx,by)' : '';
	my $argv = $args =~ s/(\w+\s*\*|int|char)//gr;
    <<"EOS"
MODULE=TVision::$fun PACKAGE=TVision::$fun
$fun* new($trecta $args)
    CODE:
        RETVAL = new $fun($trectv $argv);
    OUTPUT:
	RETVAL

EOS
    } split '\n', <<'EOS';
	TBackground(TRect, char aPattern)
	TDeskTop(TRect)
	TScroller(TRect, TScrollBar *aHScrollBar, TScrollBar *aVScrollBar)
	TLabel(TRect, TStringView aText, TView *aLink )
	TButton(TRect, char *title, int cmd, int flags)
	TScrollBar(TRect)
	TIndicator(TRect)
	TInputLine(TRect, int limit)
	TMenu()
	TEditor(TRect, TScrollBar *sb1, TScrollBar *sb2, TIndicator *ind, int n)
	TWindow(TRect, char *title, int num)
	TDialog(TRect, char *title)
	TStaticText(TRect, char *title)
EOS
}}}
{{{
    # methods:
    my $prev_p='';
    join '', map {
        my ($p, $fun, $args, $body) = /^\s*(\S+):\s*([^(]+)\s*\(\s*(.*?)\s*\)\s*(.*)$/;
	$args =~ s/TStringView/char */g;
	$args =~ s/TRect/int _ax, int ay, int bx, int by/g;
	my $line0 = $prev_p eq $p ? "" : "MODULE=TVision::$p PACKAGE=TVision::$p";
	$prev_p = $p;
    <<"EOS"
$line0
$fun($trecta $args)
    CODE:
        $body

EOS
    } split '\n', <<'EOS';
	TView: void blockCursor(TView* w) w->blockCursor();
	TView: void locate(TView *w, TRect) TRect r(_ax,ay,bx,by); w->locate(r);
	TView: void normalCursor(TView* w) w->normalCursor();
	TView: void resetCursor(TView* w) w->resetCursor();
	TView: void setCursor(TView *w, int x, int y) w->setCursor(x,y);
	TView: void showCursor(TView* w) w->showCursor();
	TView: void drawCursor(TView* w) w->drawCursor();
	TView: void focus(TView* w) w->focus();
	TGroup: void insert(TGroup *w, TWindow *what) w->insert(what);
	TInputLine: void setData(TInputLine *til, char *data) til->setData(data);
	TButton: void setTitle(TButton *w, char *title) delete w->title; w->title = new char[strlen(title)+1]; strcpy((char*)w->title,title); w->draw();
EOS
}}}

MODULE=TVision::TButton PACKAGE=TVision::TButton
SV* _new_h(int _ax, int ay, int bx, int by, char *title, int cmd, int flags)
    CODE:
	TButton *w = new TButton(TRect(_ax,ay,bx,by),title,cmd,flags);
        HV *self = newHV();
        hv_store(self, "num", 3, newSViv(cmd), 0);
        hv_store(self, "obj", 3, newSVpvn((const char *)&w, sizeof(w)), 0);
        RETVAL = newRV_inc((SV*) self);
        sv_bless(RETVAL, gv_stashpv("TVision::TButton", GV_ADD));
    OUTPUT:
	RETVAL

MODULE=TVision::TInputLine PACKAGE=TVision::TInputLine

char *getData(TInputLine *til)
    CODE:
	char data[2048]; // OMG2
	til->getData(data);
	RETVAL=data;
    OUTPUT:
	RETVAL

MODULE=TVision::TCheckBoxes PACKAGE=TVision::TCheckBoxes

TCheckBoxes* new(int _ax, int ay, int bx, int by, AV *_items)
    CODE:
        int cnt = av_count(_items);
	//printf("items=%d\n",cnt);
        TSItem *tsit = 0;
	for (int i=cnt-1; i>=0; i--) {
	    SV **sv = av_fetch(_items, i, 0);
	    //printf("i=%d s=%s\n", i, SvPV_nolen(*sv));
	    TSItem *n = new TSItem(SvPV_nolen(*sv), tsit);
	    tsit = n;
	}
        RETVAL = new TCheckBoxes(TRect(_ax,ay,bx,by), tsit);
    OUTPUT:
	RETVAL

MODULE=TVision::TRadioButtons PACKAGE=TVision::TRadioButtons

TRadioButtons* new(int _ax, int ay, int bx, int by, AV *_items)
    CODE:
        int cnt = av_count(_items);
	//printf("items=%d\n",cnt);
        TSItem *tsit = 0;
	for (int i=cnt-1; i>=0; i--) {
	    SV **sv = av_fetch(_items, i, 0);
	    //printf("i=%d s=%s\n", i, SvPV_nolen(*sv));
	    TSItem *n = new TSItem(SvPV_nolen(*sv), tsit);
	    tsit = n;
	}
        RETVAL = new TRadioButtons(TRect(_ax,ay,bx,by), tsit);
    OUTPUT:
	RETVAL

MODULE=TVision::TEditor PACKAGE=TVision::TEditor

TEditor* new_obsoleted(int _ax, int ay, int bx, int by, TScrollBar *sb1, TScrollBar *sb2, TIndicator *ind, int n)
    CODE:
	if (sb1==NULL){printf("ok got NULL\n");}
        RETVAL = new TEditor(TRect(_ax,ay,bx,by),sb1,sb2,ind, n);
    OUTPUT:
	RETVAL

MODULE=TVision::TSubMenu PACKAGE=TVision::TSubMenu

TSubMenu* new(char *nm, int key, int helpCtx = hcNoContext)
    CODE:
	// TSubMenu(TStringView nm, TKey key, ushort helpCtx = hcNoContext);
        RETVAL = new TSubMenu(TStringView(nm),key,helpCtx);
    OUTPUT:
	RETVAL

MODULE=TVision::TMenuBar PACKAGE=TVision::TMenuBar

TMenuBar* new(int _ax, int ay, int bx, int by, SV *TMenu_or_TSubMenu)
    CODE:
        TRect r(_ax,ay,bx,by);
	TMenuBar *w;
	if (sv_isa(TMenu_or_TSubMenu, "TVision::TMenu")) {
	    TMenu *m = *((TMenu**) SvPV_nolen(TMenu_or_TSubMenu));
	    w = new TMenuBar(r,m);
	} else if (sv_isa(TMenu_or_TSubMenu, "TVision::TSubMenu")) {
	    TSubMenu sm = **((TSubMenu**) SvPV_nolen(TMenu_or_TSubMenu));
	    w = new TMenuBar(r,sm);
	} else {
	    croak("wrong inheritance in TVision::TMenuBar::new");
	}
        RETVAL = w;
    OUTPUT:
	RETVAL

#if 0
MODULE=TVision::TEditWindow PACKAGE=TVision::TEditWindow
TEditWindow* new(int _ax, int ay, int bx, int by, char *title, int num)
    CODE:
        RETVAL = new TEditWindow(TRect(_ax,ay,bx,by),title,num);
    OUTPUT:
	RETVAL
#endif

MODULE=TVision::TDeskTop PACKAGE=TVision::TDeskTop

void insert_obsoleted(SV *self, SV *what)
    CODE:
	TDeskTop* td = sv2tv_s(self,TDeskTop);
        SV *sv = SvRV(what);
        TWindow* w = *((TWindow**) SvPV_nolen(sv));
	td->insert(w);

MODULE=TVision_more PACKAGE=TVision

